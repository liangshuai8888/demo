<!doctype html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>鼠标移入移出改变背景色</title>
	<style>
		ul,li{margin:0;padding:0;list-style-type: none}
		#imgList{width:700px;border:1px solid #333;overflow:hidden;zoom:1;margin:0 auto;padding:0 0 10px 10px;clear:both;}
		#imgList li{float:left;width:128px;height:128px;border:1px solid #ccc;margin:10px 10px 0 0;}
		#imgList li img{opacity:0.3;}
		#imgList li.current img{opacity:1;}

	</style>
</head>
<body>
	<ul id="imgList">
		<li><img src="images/1.jpg" alt=""></li>
		<li><img src="images/2.jpg" alt=""></li>
		<li><img src="images/3.jpg" alt=""></li>
		<li><img src="images/4.jpg" alt=""></li>
		<li><img src="images/5.jpg" alt=""></li>
		<li><img src="images/6.jpg" alt=""></li>
		<li><img src="images/7.jpg" alt=""></li>
		<li><img src="images/8.jpg" alt=""></li>
		<li><img src="images/9.jpg" alt=""></li>
		<li><img src="images/10.jpg" alt=""></li>
	</ul>

	<script>

		window.onload=function(){
			var oLis=document.getElementsByTagName("li");
		
			
			for(var i=0;i<oLis.length;i++){
					oLis[i].index = i;
					oLis[i].onmouseover = function(){
						// alert(this.index);
						this.className="current";
					}				
					oLis[i].onmouseout = function(){
						
						this.className="";
					}

				}	

		}










		//属性 img[src=img/$.jpg]
		//知识点： 外框盒子高度自适应   #imgList{overflow:hidden;zoom:1}  自适应包含元素的高度
	/*	我们知道overflow属性设置当元素的内容溢出其区域时发生的事情。这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。而hidden正相反，会自动剪切多出的内容。

		现在就有一个问题了：

		应该说，外包含框高度为0，那么它应该剪切所有的内容，即不显示任何内容。但是试验的结果却相反。这不得不让人思考其他问题：为什么呢？

		考虑这个问题，我们应该从浏览器的解析机制开始，首先，浏览器遵循从上到下、从内到外的顺序来解析HTML结构，然后再解析这些结构的CSS样式。

		而CSS属性的解析也是有顺序的，一般会遵循先主后次的顺序，也就是说overflow属性晚于其他属性进行解析，当浏览器解析完<div id="div1">的样式时，它会按着一定的逻辑不断进行计算。当解析overflow属性，它要完成几个计算问题：第一，元素本身是否定义了高度，第二，元素的布局模式，第三，包含子元素的大小。如果当元素没有明确定义高度的情况下，而布局又是以流动布局显示，此时它会考虑子元素的高度。也就是说，此时overflow:hidden声明触发了浏览器重新计算包含框的高度的可能性，此时它会考虑到子元素的高度，并努力包含子元素，避免子元素被裁切显示。因此，我们会看到了使用overflow:hidden声明之后，包含框能够自适应包含内部的子元素。

		实际上，这是两种逻辑计算的重合所引发的一个有趣话题。*/

	//事件委托   ：利用冒泡的原理，把事件加到父级上，触发执行效果，
				//提高性能   动态添加元素，绑定事件

	</script>
</body>
</html>